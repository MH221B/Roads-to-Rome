import { afterAll, afterEach, beforeAll, describe, expect, it, vi } from 'vitest';
import request, { Response } from 'supertest';
import app from '../app';
import authService from '../services/auth.service';
import { User } from '../models/user.model';

const testUser = {
  email: 'test@example.com',
  password: 'password123',
  role: 'student',
  username: 'testuser',
  fullName: 'Test User',
};

const registerTestUser = () => request(app).post('/api/auth/register').send(testUser);
const loginTestUser = () =>
  request(app).post('/api/auth/login').send({ email: testUser.email, password: testUser.password });

const normalizeCookieHeader = (header: string | string[] | undefined): string[] | undefined => {
  if (!header) {
    return undefined;
  }

  return Array.isArray(header) ? header : [header];
};

const extractRefreshTokenCookie = (response: Response) => {
  const cookies = normalizeCookieHeader(response.headers['set-cookie']);
  expect(cookies).toBeDefined();
  const refreshCookie = cookies!.find((cookie) => cookie.startsWith('refreshToken='));
  expect(refreshCookie).toBeDefined();
  return refreshCookie!;
};

describe('Auth Routes', () => {
  describe('Registration', () => {
    it('creates a user when given valid credentials', async () => {
      const res = await registerTestUser();

      expect(res.status).toBe(201);
      expect(res.body).toHaveProperty('message', 'User registered successfully');
    });

    it('rejects duplicate registrations', async () => {
      await registerTestUser();
      const res = await registerTestUser();

      expect(res.status).toBe(400);
      expect(res.body).toHaveProperty('error', 'User already exists');
    });
  });

  describe('Session management', () => {
    it('issues tokens and a refresh cookie when logging in', async () => {
      await registerTestUser();
      const res = await loginTestUser();

      expect(res.status).toBe(200);
      expect(res.body).toHaveProperty('accessToken');

      const refreshCookie = extractRefreshTokenCookie(res);
      expect(refreshCookie).toContain('HttpOnly');
    });

    it('returns a fresh access token when the refresh cookie is presented', async () => {
      await registerTestUser();
      const loginRes = await loginTestUser();
      const refreshCookie = extractRefreshTokenCookie(loginRes);

      const refreshRes = await request(app)
        .post('/api/auth/refresh-token')
        .set('Cookie', [refreshCookie]);

      expect(refreshRes.status).toBe(200);
      expect(refreshRes.body).toHaveProperty('accessToken');
    });

    it('clears the refresh cookie on logout', async () => {
      await registerTestUser();
      const loginRes = await loginTestUser();
      const refreshCookie = extractRefreshTokenCookie(loginRes);

      const logoutRes = await request(app).post('/api/auth/logout').set('Cookie', [refreshCookie]);

      expect(logoutRes.status).toBe(200);
      expect(logoutRes.body).toHaveProperty('message', 'Logged out successfully');

      const logoutCookies = normalizeCookieHeader(logoutRes.headers['set-cookie']);
      expect(logoutCookies).toBeDefined();
      expect(logoutCookies!.some((cookie) => cookie.includes('refreshToken=;'))).toBe(true);
    });
  });

  describe('GitHub OAuth flow', () => {
    const githubEmail = 'gituser@example.com';
    const originalClientId = process.env.GITHUB_CLIENT_ID;
    const originalClientSecret = process.env.GITHUB_CLIENT_SECRET;

    beforeAll(() => {
      process.env.GITHUB_CLIENT_ID = 'test-client-id';
      process.env.GITHUB_CLIENT_SECRET = 'test-client-secret';
    });

    afterAll(() => {
      process.env.GITHUB_CLIENT_ID = originalClientId;
      process.env.GITHUB_CLIENT_SECRET = originalClientSecret;
    });

    afterEach(() => {
      vi.resetAllMocks();
      vi.unstubAllGlobals();
    });

    it('creates a GitHub-linked user with a hashed password', async () => {
      const fetchMock = vi
        .fn()
        .mockResolvedValueOnce({
          ok: true,
          json: async () => ({ access_token: 'gh_test_token' }),
        })
        .mockResolvedValueOnce({
          ok: true,
          json: async () => [
            {
              email: githubEmail,
              primary: true,
              verified: true,
            },
          ],
        });

      // mock the profile fetch (login + name) so created user has username/fullName
      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ login: 'gituser', name: 'Git User' }),
      });

      vi.stubGlobal('fetch', fetchMock);

      const tokens = await authService.GithubLogin('fake_code');
      expect(tokens).toHaveProperty('accessToken');
      expect(tokens).toHaveProperty('refreshToken');

      const user = await User.findOne({ email: githubEmail });
      expect(user).toBeDefined();
      expect(user?.githubAutoGenerated).toBe(true);
      expect(user?.password).toBeDefined();
      expect(typeof user?.password).toBe('string');
      expect(user?.password.length).toBeGreaterThan(0);
    });
  });
});
